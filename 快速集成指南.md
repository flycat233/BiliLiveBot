# 快速集成指南

本指南帮助您快速将所有优化功能集成到现有项目中。

## 步骤1：安装依赖

```bash
cd backend
pip install pyjwt psutil
```

## 步骤2：修改server.py

在`server.py`文件开头添加导入：

```python
# 在现有导入后添加
from core.logger import get_logger
from core.config import get_config
from core.database import db
from core.performance import performance_monitor
from core.danmaku_enhanced import EnhancedDanmakuClient
import api_extended

# 替换print为logger
logger = get_logger("server")
```

## 步骤3：注册扩展API

在创建FastAPI应用后添加：

```python
# 在 app = FastAPI(...) 后添加
app.include_router(api_extended.router)
```

## 步骤4：修改startup事件

找到`@app.on_event("startup")`部分，修改为：

```python
@app.on_event("startup")
async def startup_event():
    """应用启动时执行"""
    logger.info("=" * 60)
    logger.info("正在加载插件...")
    plugin_manager.load_all_plugins()
    
    # 设置WebSocket管理器到插件系统
    plugin_manager.set_websocket_manager(manager)
    logger.info("插件加载完成")
    
    # 启动性能监控
    if get_config('monitoring.enable_performance_monitor', True):
        logger.info("启动性能监控...")
        interval = get_config('monitoring.metrics_interval_seconds', 60)
        await performance_monitor.start_monitoring(interval)
    
    # 启动数据备份任务
    if get_config('database.backup_enabled', True):
        logger.info("启动数据备份任务...")
        asyncio.create_task(backup_task())
    
    logger.info("=" * 60)


async def backup_task():
    """定期备份任务"""
    interval_hours = get_config('database.backup_interval_hours', 24)
    interval_seconds = interval_hours * 3600
    
    while True:
        try:
            await asyncio.sleep(interval_seconds)
            logger.info("执行定期备份...")
            db.backup()
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"备份任务错误: {e}", exc_info=True)
```

## 步骤5：添加shutdown事件

```python
@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭时执行"""
    logger.info("=" * 60)
    logger.info("正在关闭服务...")
    
    # 停止性能监控
    await performance_monitor.stop_monitoring()
    
    # 备份数据库
    logger.info("备份数据库...")
    db.backup()
    
    # 清理旧数据
    logger.info("清理旧数据...")
    days = get_config('database.cleanup_days', 30)
    db.clean_old_data(days)
    
    logger.info("服务已关闭")
    logger.info("=" * 60)
```

## 步骤6：替换DanmakuClient

找到`connect_room`函数，将`DanmakuClient`替换为`EnhancedDanmakuClient`：

```python
async def connect_room(room_id: int, websocket: WebSocket):
    """连接到直播间"""
    global danmaku_client

    try:
        # 断开之前的连接
        if danmaku_client:
            await danmaku_client.disconnect()
            danmaku_client = None

        # 创建新客户端（使用增强版）
        cookies = auth_manager.get_cookies_dict()
        danmaku_client = EnhancedDanmakuClient(room_id, cookies)
        
        # 设置重连回调
        async def on_reconnect_start():
            await manager.broadcast({
                "type": "reconnecting",
                "message": "连接断开，正在重连..."
            })
        
        async def on_reconnect_success():
            await manager.broadcast({
                "type": "reconnected",
                "message": "重连成功"
            })
        
        async def on_reconnect_failed():
            await manager.broadcast({
                "type": "reconnect_failed",
                "message": "重连失败，请手动重新连接"
            })
        
        danmaku_client.on_reconnect_start = on_reconnect_start
        danmaku_client.on_reconnect_success = on_reconnect_success
        danmaku_client.on_reconnect_failed = on_reconnect_failed

        # 设置回调函数
        danmaku_client.on_danmaku = lambda data: handle_danmaku("danmaku", data)
        danmaku_client.on_gift = lambda data: handle_danmaku("gift", data)
        danmaku_client.on_superchat = lambda data: handle_danmaku("superchat", data)
        danmaku_client.on_guard = lambda data: handle_danmaku("guard", data)
        danmaku_client.on_interact = lambda data: handle_danmaku("interact", data)
        danmaku_client.on_online = lambda data: handle_danmaku("online", data)
        
        # 传递插件管理器引用
        danmaku_client.plugin_manager = plugin_manager

        # 初始化弹幕发送器
        init_danmaku_sender(cookies, room_id)
        logger.info(f"弹幕发送器已初始化，房间号: {room_id}")
        
        # 连接
        success = await danmaku_client.connect()

        # 检查WebSocket是否仍然连接
        if websocket.client_state.name != "CONNECTED":
            logger.warning("WebSocket已断开，取消连接")
            if danmaku_client:
                await danmaku_client.disconnect()
                danmaku_client = None
            return

        if success:
            try:
                await websocket.send_json({
                    "type": "connected",
                    "room_id": room_id,
                    "message": "连接成功"
                })
                logger.info(f"已向客户端发送连接成功消息，房间号: {room_id}")
            except Exception as send_error:
                logger.error(f"发送连接成功消息失败: {send_error}")
                if danmaku_client:
                    await danmaku_client.disconnect()
                    danmaku_client = None
        else:
            await danmaku_client.disconnect()
            danmaku_client = None
            try:
                await websocket.send_json({
                    "type": "error",
                    "message": "连接失败"
                })
                logger.warning("已向客户端发送连接失败消息")
            except Exception as send_error:
                logger.error(f"发送连接失败消息失败: {send_error}")

    except Exception as e:
        if danmaku_client:
            try:
                await danmaku_client.disconnect()
            except:
                pass
            danmaku_client = None

        try:
            await websocket.send_json({
                "type": "error",
                "message": f"连接失败: {str(e)}"
            })
        except Exception as send_error:
            logger.error(f"发送错误消息失败: {send_error}")
```

## 步骤7：集成数据库保存

在`handle_danmaku`函数中添加数据库保存：

```python
async def handle_danmaku(event_type: str, data: dict):
    """处理弹幕数据（通过插件系统）"""
    try:
        # 保存到数据库
        if event_type == "danmaku":
            try:
                db.save_danmaku(data)
            except Exception as e:
                logger.error(f"保存弹幕到数据库失败: {e}")
        
        elif event_type == "gift":
            try:
                db.save_gift(data)
            except Exception as e:
                logger.error(f"保存礼物到数据库失败: {e}")
        
        # 通过插件系统处理
        processed_data = await plugin_manager.process_event(event_type, data)
        
        # 如果插件返回 None，表示过滤掉该消息
        if processed_data is None:
            return
        
        # 广播到所有客户端
        await manager.broadcast({
            "type": event_type,
            "data": processed_data
        })
    
    except Exception as e:
        logger.error(f"处理弹幕错误: {e}", exc_info=True)
        performance_monitor.record_error()
```

## 步骤8：更新WebSocket连接管理

在`ConnectionManager`类中添加连接数统计：

```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        # 更新连接数
        performance_monitor.set_websocket_connections(len(self.active_connections))
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        # 更新连接数
        performance_monitor.set_websocket_connections(len(self.active_connections))
    
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            try:
                await connection.send_json(message)
            except:
                pass
```

## 步骤9：测试集成

启动服务器：

```bash
python server.py
```

测试新功能：

```bash
# 测试性能监控
curl http://localhost:8000/api/v2/performance/metrics

# 测试健康检查
curl http://localhost:8000/api/v2/performance/health

# 测试数据导出
curl -X POST http://localhost:8000/api/v2/export \
  -H "Content-Type: application/json" \
  -d '{"data_type":"user_analytics","format":"json"}'
```

## 步骤10：配置调整

根据需要修改`./data/config.json`：

```json
{
  "server": {
    "host": "0.0.0.0",
    "port": 8000
  },
  "reconnect": {
    "enable_auto_reconnect": true,
    "max_retries": 10,
    "retry_delay_seconds": 3
  },
  "monitoring": {
    "enable_performance_monitor": true,
    "metrics_interval_seconds": 60
  },
  "database": {
    "backup_enabled": true,
    "backup_interval_hours": 24
  }
}
```

## 完成！

现在您的项目已经集成了所有优化功能：

✅ 自动断线重连
✅ 完善的日志系统
✅ 数据持久化
✅ 性能监控
✅ 数据导出
✅ API扩展

查看日志：`./logs/`
查看数据库：`./data/database.db`
查看备份：`./data/backups/`
查看导出：`./data/exports/`

## 可选：使用独立启动脚本

如果不想修改原server.py，可以直接使用：

```bash
python server_enhanced.py
```

这个脚本会自动集成所有优化功能。
